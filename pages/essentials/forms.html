Form Input Bindings ​Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolWhen dealing with forms on the frontend, we often need to sync the state of form input elements with corresponding state in JavaScript. It can be cumbersome to manually wire up value bindings and change event listeners:template&lt;input
  :value="text"
  @input="event =&gt; text = event.target.value"&gt;
The v-model directive helps us simplify the above to:template&lt;input v-model="text"&gt;
In addition, v-model can be used on inputs of different types, &lt;textarea&gt;, and &lt;select&gt; elements. It automatically expands to different DOM property and event pairs based on the element it is used on:&lt;input&gt; with text types and &lt;textarea&gt; elements use value property and input event;&lt;input type="checkbox"&gt; and &lt;input type="radio"&gt; use checked property and change event;&lt;select&gt; use value as a prop and change as an event.Notev-model will ignore the initial value, checked or selected attributes found on any form elements. It will always treat the current bound JavaScript state as the source of truth. You should declare the initial value on the JavaScript side, using the data optionreactivity APIs.Basic Usage ​Text ​template&lt;p&gt;Message is: {{ message }}&lt;/p&gt;
&lt;input v-model="message" placeholder="edit me" /&gt;
Message is: Try it in the PlaygroundTry it in the PlaygroundNoteFor languages that require an IME (Chinese, Japanese, Korean etc.), you'll notice that v-model doesn't get updated during IME composition. If you want to respond to these updates as well, use your own input event listener and value binding instead of using v-model.Multiline text ​template&lt;span&gt;Multiline message is:&lt;/span&gt;
&lt;p style="white-space: pre-line;"&gt;{{ message }}&lt;/p&gt;
&lt;textarea v-model="message" placeholder="add multiple lines"&gt;&lt;/textarea&gt;
Multiline message is:Try it in the PlaygroundTry it in the PlaygroundNote that interpolation inside &lt;textarea&gt; won't work. Use v-model instead.template&lt;!-- bad --&gt;
&lt;textarea&gt;{{ text }}&lt;/textarea&gt;

&lt;!-- good --&gt;
&lt;textarea v-model="text"&gt;&lt;/textarea&gt;
Checkbox ​Single checkbox, boolean value:template&lt;input type="checkbox" id="checkbox" v-model="checked" /&gt;
&lt;label for="checkbox"&gt;{{ checked }}&lt;/label&gt;
falseTry it in the PlaygroundTry it in the PlaygroundWe can also bind multiple checkboxes to the same array or Set value:jsconst checkedNames = ref([])
jsexport default {
  data() {
    return {
      checkedNames: []
    }
  }
}
template&lt;div&gt;Checked names: {{ checkedNames }}&lt;/div&gt;

&lt;input type="checkbox" id="jack" value="Jack" v-model="checkedNames"&gt;
&lt;label for="jack"&gt;Jack&lt;/label&gt;

&lt;input type="checkbox" id="john" value="John" v-model="checkedNames"&gt;
&lt;label for="john"&gt;John&lt;/label&gt;

&lt;input type="checkbox" id="mike" value="Mike" v-model="checkedNames"&gt;
&lt;label for="mike"&gt;Mike&lt;/label&gt;
Checked names: []JackJohnMikeIn this case, the checkedNames array will always contain the values from the currently checked boxes.Try it in the PlaygroundTry it in the PlaygroundRadio ​template&lt;div&gt;Picked: {{ picked }}&lt;/div&gt;

&lt;input type="radio" id="one" value="One" v-model="picked" /&gt;
&lt;label for="one"&gt;One&lt;/label&gt;

&lt;input type="radio" id="two" value="Two" v-model="picked" /&gt;
&lt;label for="two"&gt;Two&lt;/label&gt;
Picked: OneTwoTry it in the PlaygroundTry it in the PlaygroundSelect ​Single select:template&lt;div&gt;Selected: {{ selected }}&lt;/div&gt;

&lt;select v-model="selected"&gt;
  &lt;option disabled value=""&gt;Please select one&lt;/option&gt;
  &lt;option&gt;A&lt;/option&gt;
  &lt;option&gt;B&lt;/option&gt;
  &lt;option&gt;C&lt;/option&gt;
&lt;/select&gt;
Selected: Please select oneABCTry it in the PlaygroundTry it in the PlaygroundNoteIf the initial value of your v-model expression does not match any of the options, the &lt;select&gt; element will render in an "unselected" state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.Multiple select (bound to array):template&lt;div&gt;Selected: {{ selected }}&lt;/div&gt;

&lt;select v-model="selected" multiple&gt;
  &lt;option&gt;A&lt;/option&gt;
  &lt;option&gt;B&lt;/option&gt;
  &lt;option&gt;C&lt;/option&gt;
&lt;/select&gt;
Selected: []ABCTry it in the PlaygroundTry it in the PlaygroundSelect options can be dynamically rendered with v-for:jsconst selected = ref('A')

const options = ref([
  { text: 'One', value: 'A' },
  { text: 'Two', value: 'B' },
  { text: 'Three', value: 'C' }
])
jsexport default {
  data() {
    return {
      selected: 'A',
      options: [
        { text: 'One', value: 'A' },
        { text: 'Two', value: 'B' },
        { text: 'Three', value: 'C' }
      ]
    }
  }
}
template&lt;select v-model="selected"&gt;
  &lt;option v-for="option in options" :value="option.value"&gt;
    {{ option.text }}
  &lt;/option&gt;
&lt;/select&gt;

&lt;div&gt;Selected: {{ selected }}&lt;/div&gt;
Try it in the PlaygroundTry it in the PlaygroundValue Bindings ​For radio, checkbox and select options, the v-model binding values are usually static strings (or booleans for checkbox):template&lt;!-- `picked` is a string "a" when checked --&gt;
&lt;input type="radio" v-model="picked" value="a" /&gt;

&lt;!-- `toggle` is either true or false --&gt;
&lt;input type="checkbox" v-model="toggle" /&gt;

&lt;!-- `selected` is a string "abc" when the first option is selected --&gt;
&lt;select v-model="selected"&gt;
  &lt;option value="abc"&gt;ABC&lt;/option&gt;
&lt;/select&gt;
But sometimes we may want to bind the value to a dynamic property on the current active instance. We can use v-bind to achieve that. In addition, using v-bind allows us to bind the input value to non-string values.Checkbox ​template&lt;input
  type="checkbox"
  v-model="toggle"
  true-value="yes"
  false-value="no" /&gt;
true-value and false-value are Vue-specific attributes that only work with v-model. Here the toggle property's value will be set to 'yes' when the box is checked, and set to 'no' when unchecked. You can also bind them to dynamic values using v-bind:template&lt;input
  type="checkbox"
  v-model="toggle"
  :true-value="dynamicTrueValue"
  :false-value="dynamicFalseValue" /&gt;
TipThe true-value and false-value attributes don't affect the input's value attribute, because browsers don't include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (e.g. "yes" or "no"), use radio inputs instead.Radio ​template&lt;input type="radio" v-model="pick" :value="first" /&gt;
&lt;input type="radio" v-model="pick" :value="second" /&gt;
pick will be set to the value of first when the first radio input is checked, and set to the value of second when the second one is checked.Select Options ​template&lt;select v-model="selected"&gt;
  &lt;!-- inline object literal --&gt;
  &lt;option :value="{ number: 123 }"&gt;123&lt;/option&gt;
&lt;/select&gt;
v-model supports value bindings of non-string values as well! In the above example, when the option is selected, selected will be set to the object literal value of { number: 123 }.Modifiers ​.lazy ​By default, v-model syncs the input with the data after each input event (with the exception of IME composition as stated above). You can add the lazy modifier to instead sync after change events:template&lt;!-- synced after "change" instead of "input" --&gt;
&lt;input v-model.lazy="msg" /&gt;
.number ​If you want user input to be automatically typecast as a number, you can add the number modifier to your v-model managed inputs:template&lt;input v-model.number="age" /&gt;
If the value cannot be parsed with parseFloat(), then the original value is used instead.The number modifier is applied automatically if the input has type="number"..trim ​If you want whitespace from user input to be trimmed automatically, you can add the trim modifier to your v-model-managed inputs:template&lt;input v-model.trim="msg" /&gt;
v-model with Components ​If you're not yet familiar with Vue's components, you can skip this for now.HTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with v-model! To learn more, read about Usage with v-model in the Components guide.Edit this page on GitHub