Class and Style Bindings ​A common need for data binding is manipulating an element's class list and inline styles. Since class and style are both attributes, we can use v-bind to assign them a string value dynamically, much like with other attributes. However, trying to generate those values using string concatenation can be annoying and error-prone. For this reason, Vue provides special enhancements when v-bind is used with class and style. In addition to strings, the expressions can also evaluate to objects or arrays.Binding HTML Classes ​Watch a free video lesson on Vue SchoolWatch a free video lesson on Vue SchoolBinding to Objects ​We can pass an object to :class (short for v-bind:class) to dynamically toggle classes:template&lt;div :class="{ active: isActive }"&gt;&lt;/div&gt;
The above syntax means the presence of the active class will be determined by the truthiness of the data property isActive.You can have multiple classes toggled by having more fields in the object. In addition, the :class directive can also co-exist with the plain class attribute. So given the following state:jsconst isActive = ref(true)
const hasError = ref(false)
jsdata() {
  return {
    isActive: true,
    hasError: false
  }
}
And the following template:template&lt;div
  class="static"
  :class="{ active: isActive, 'text-danger': hasError }"
&gt;&lt;/div&gt;
It will render:template&lt;div class="static active"&gt;&lt;/div&gt;
When isActive or hasError changes, the class list will be updated accordingly. For example, if hasError becomes true, the class list will become "static active text-danger".The bound object doesn't have to be inline:jsconst classObject = reactive({
  active: true,
  'text-danger': false
})
jsdata() {
  return {
    classObject: {
      active: true,
      'text-danger': false
    }
  }
}
template&lt;div :class="classObject"&gt;&lt;/div&gt;
This will render the same result. We can also bind to a computed property that returns an object. This is a common and powerful pattern:jsconst isActive = ref(true)
const error = ref(null)

const classObject = computed(() =&gt; ({
  active: isActive.value &amp;&amp; !error.value,
  'text-danger': error.value &amp;&amp; error.value.type === 'fatal'
}))
jsdata() {
  return {
    isActive: true,
    error: null
  }
},
computed: {
  classObject() {
    return {
      active: this.isActive &amp;&amp; !this.error,
      'text-danger': this.error &amp;&amp; this.error.type === 'fatal'
    }
  }
}
template&lt;div :class="classObject"&gt;&lt;/div&gt;
Binding to Arrays ​We can bind :class to an array to apply a list of classes:jsconst activeClass = ref('active')
const errorClass = ref('text-danger')
jsdata() {
  return {
    activeClass: 'active',
    errorClass: 'text-danger'
  }
}
template&lt;div :class="[activeClass, errorClass]"&gt;&lt;/div&gt;
Which will render:template&lt;div class="active text-danger"&gt;&lt;/div&gt;
If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:template&lt;div :class="[isActive ? activeClass : '', errorClass]"&gt;&lt;/div&gt;
This will always apply errorClass, but activeClass will only be applied when isActive is truthy.However, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside array syntax:template&lt;div :class="[{ active: isActive }, errorClass]"&gt;&lt;/div&gt;
With Components ​This section assumes knowledge of Components. Feel free to skip it and come back later.When you use the class attribute on a component with a single root element, those classes will be added to the component's root element, and merged with any existing class already on it.For example, if we have a component named MyComponent with the following template:template&lt;!-- child component template --&gt;
&lt;p class="foo bar"&gt;Hi!&lt;/p&gt;
Then add some classes when using it:template&lt;!-- when using the component --&gt;
&lt;MyComponent class="baz boo" /&gt;
The rendered HTML will be:template&lt;p class="foo bar baz boo"&gt;Hi!&lt;/p&gt;
The same is true for class bindings:template&lt;MyComponent :class="{ active: isActive }" /&gt;
When isActive is truthy, the rendered HTML will be:template&lt;p class="foo bar active"&gt;Hi!&lt;/p&gt;
If your component has multiple root elements, you would need to define which element will receive this class. You can do this using the $attrs component property:template&lt;!-- MyComponent template using $attrs --&gt;
&lt;p :class="$attrs.class"&gt;Hi!&lt;/p&gt;
&lt;span&gt;This is a child component&lt;/span&gt;
template&lt;MyComponent class="baz" /&gt;
Will render:html&lt;p class="baz"&gt;Hi!&lt;/p&gt;
&lt;span&gt;This is a child component&lt;/span&gt;
You can learn more about component attribute inheritance in Fallthrough Attributes section.Binding Inline Styles ​Binding to Objects ​:style supports binding to JavaScript object values - it corresponds to an HTML element's style property:jsconst activeColor = ref('red')
const fontSize = ref(30)
jsdata() {
  return {
    activeColor: 'red',
    fontSize: 30
  }
}
template&lt;div :style="{ color: activeColor, fontSize: fontSize + 'px' }"&gt;&lt;/div&gt;
Although camelCase keys are recommended, :style also supports kebab-cased CSS property keys (corresponds to how they are used in actual CSS) - for example:template&lt;div :style="{ 'font-size': fontSize + 'px' }"&gt;&lt;/div&gt;
It is often a good idea to bind to a style object directly so that the template is cleaner:jsconst styleObject = reactive({
  color: 'red',
  fontSize: '13px'
})
jsdata() {
  return {
    styleObject: {
      color: 'red',
      fontSize: '13px'
    }
  }
}
template&lt;div :style="styleObject"&gt;&lt;/div&gt;
Again, object style binding is often used in conjunction with computed properties that return objects.Binding to Arrays ​We can bind :style to an array of multiple style objects. These objects will be merged and applied to the same element:template&lt;div :style="[baseStyles, overridingStyles]"&gt;&lt;/div&gt;
Auto-prefixing ​When you use a CSS property that requires a vendor prefix in :style, Vue will automatically add the appropriate prefix. Vue does this by checking at runtime to see which style properties are supported in the current browser. If the browser doesn't support a particular property then various prefixed variants will be tested to try to find one that is supported.Multiple Values ​You can provide an array of multiple (prefixed) values to a style property, for example:template&lt;div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"&gt;&lt;/div&gt;
This will only render the last value in the array which the browser supports. In this example, it will render display: flex for browsers that support the unprefixed version of flexbox.Edit this page on GitHub