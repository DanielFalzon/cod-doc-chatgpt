Watchers ​Basic Example ​Computed properties allow us to declaratively compute derived values. However, there are cases where we need to perform "side effects" in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation.With the Options API, we can use the watch option to trigger a function whenever a reactive property changes:jsexport default {
  data() {
    return {
      question: '',
      answer: 'Questions usually contain a question mark. ;-)'
    }
  },
  watch: {
    // whenever question changes, this function will run
    question(newQuestion, oldQuestion) {
      if (newQuestion.includes('?')) {
        this.getAnswer()
      }
    }
  },
  methods: {
    async getAnswer() {
      this.answer = 'Thinking...'
      try {
        const res = await fetch('https://yesno.wtf/api')
        this.answer = (await res.json()).answer
      } catch (error) {
        this.answer = 'Error! Could not reach the API. ' + error
      }
    }
  }
}
template&lt;p&gt;
  Ask a yes/no question:
  &lt;input v-model="question" /&gt;
&lt;/p&gt;
&lt;p&gt;{{ answer }}&lt;/p&gt;
Try it in the PlaygroundThe watch option also supports a dot-delimited path as the key:jsexport default {
  watch: {
    // Note: only simple paths. Expressions are not supported.
    'some.nested.key'(newValue) {
      // ...
    }
  }
}
With Composition API, we can use the watch function to trigger a callback whenever a piece of reactive state changes:vue&lt;script setup&gt;
import { ref, watch } from 'vue'

const question = ref('')
const answer = ref('Questions usually contain a question mark. ;-)')

// watch works directly on a ref
watch(question, async (newQuestion, oldQuestion) =&gt; {
  if (newQuestion.indexOf('?') &gt; -1) {
    answer.value = 'Thinking...'
    try {
      const res = await fetch('https://yesno.wtf/api')
      answer.value = (await res.json()).answer
    } catch (error) {
      answer.value = 'Error! Could not reach the API. ' + error
    }
  }
})
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;
    Ask a yes/no question:
    &lt;input v-model="question" /&gt;
  &lt;/p&gt;
  &lt;p&gt;{{ answer }}&lt;/p&gt;
&lt;/template&gt;
Try it in the PlaygroundWatch Source Types ​watch's first argument can be different types of reactive "sources": it can be a ref (including computed refs), a reactive object, a getter function, or an array of multiple sources:jsconst x = ref(0)
const y = ref(0)

// single ref
watch(x, (newX) =&gt; {
  console.log(`x is ${newX}`)
})

// getter
watch(
  () =&gt; x.value + y.value,
  (sum) =&gt; {
    console.log(`sum of x + y is: ${sum}`)
  }
)

// array of multiple sources
watch([x, () =&gt; y.value], ([newX, newY]) =&gt; {
  console.log(`x is ${newX} and y is ${newY}`)
})
Do note that you can't watch a property of a reactive object like this:jsconst obj = reactive({ count: 0 })

// this won't work because we are passing a number to watch()
watch(obj.count, (count) =&gt; {
  console.log(`count is: ${count}`)
})
Instead, use a getter:js// instead, use a getter:
watch(
  () =&gt; obj.count,
  (count) =&gt; {
    console.log(`count is: ${count}`)
  }
)
Deep Watchers ​watch is shallow by default: the callback will only trigger when the watched property has been assigned a new value - it won't trigger on nested property changes. If you want the callback to fire on all nested mutations, you need to use a deep watcher:jsexport default {
  watch: {
    someObject: {
      handler(newValue, oldValue) {
        // Note: `newValue` will be equal to `oldValue` here
        // on nested mutations as long as the object itself
        // hasn't been replaced.
      },
      deep: true
    }
  }
}
When you call watch() directly on a reactive object, it will implicitly create a deep watcher - the callback will be triggered on all nested mutations:jsconst obj = reactive({ count: 0 })

watch(obj, (newValue, oldValue) =&gt; {
  // fires on nested property mutations
  // Note: `newValue` will be equal to `oldValue` here
  // because they both point to the same object!
})

obj.count++
This should be differentiated with a getter that returns a reactive object - in the latter case, the callback will only fire if the getter returns a different object:jswatch(
  () =&gt; state.someObject,
  () =&gt; {
    // fires only when state.someObject is replaced
  }
)
You can, however, force the second case into a deep watcher by explicitly using the deep option:jswatch(
  () =&gt; state.someObject,
  (newValue, oldValue) =&gt; {
    // Note: `newValue` will be equal to `oldValue` here
    // *unless* state.someObject has been replaced
  },
  { deep: true }
)
Use with CautionDeep watch requires traversing all nested properties in the watched object, and can be expensive when used on large data structures. Use it only when necessary and beware of the performance implications.Eager Watchers ​watch is lazy by default: the callback won't be called until the watched source has changed. But in some cases we may want the same callback logic to be run eagerly - for example, we may want to fetch some initial data, and then re-fetch the data whenever relevant state changes.We can force a watcher's callback to be executed immediately by declaring it using an object with a handler function and the immediate: true option:jsexport default {
  // ...
  watch: {
    question: {
      handler(newQuestion) {
        // this will be run immediately on component creation.
      },
      // force eager callback execution
      immediate: true
    }
  }
  // ...
}
The initial execution of the handler function will happen just before the created hook. Vue will have already processed the data, computed, and methods options, so those properties will be available on the first invocation.We can force a watcher's callback to be executed immediately by passing the immediate: true option:jswatch(source, (newValue, oldValue) =&gt; {
  // executed immediately, then again when `source` changes
}, { immediate: true })
watchEffect() ​It is common for the watcher callback to use exactly the same reactive state as the source. For example, consider the following code, which uses a watcher to load a remote resource whenever the todoId ref changes:jsconst todoId = ref(1)
const data = ref(null)

watch(todoId, async () =&gt; {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
}, { immediate: true })
In particular, notice how the watcher uses todoId twice, once as the source and then again inside the callback.This can be simplified with watchEffect(). watchEffect() allows us to track the callback's reactive dependencies automatically. The watcher above can be rewritten as:jswatchEffect(async () =&gt; {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
})
Here, the callback will run immediately, there's no need to specify immediate: true. During its execution, it will automatically track todoId.value as a dependency (similar to computed properties). Whenever todoId.value changes, the callback will be run again. With watchEffect(), we no longer need to pass todoId explicitly as the source value.You can check out this example of watchEffect() and reactive data-fetching in action.For examples like these, with only one dependency, the benefit of watchEffect() is relatively small. But for watchers that have multiple dependencies, using watchEffect() removes the burden of having to maintain the list of dependencies manually. In addition, if you need to watch several properties in a nested data structure, watchEffect() may prove more efficient than a deep watcher, as it will only track the properties that are used in the callback, rather than recursively tracking all of them.TIPwatchEffect only tracks dependencies during its synchronous execution. When using it with an async callback, only properties accessed before the first await tick will be tracked.watch vs. watchEffect ​watch and watchEffect both allow us to reactively perform side effects. Their main difference is the way they track their reactive dependencies:watch only tracks the explicitly watched source. It won't track anything accessed inside the callback. In addition, the callback only triggers when the source has actually changed. watch separates dependency tracking from the side effect, giving us more precise control over when the callback should fire.watchEffect, on the other hand, combines dependency tracking and side effect into one phase. It automatically tracks every reactive property accessed during its synchronous execution. This is more convenient and typically results in terser code, but makes its reactive dependencies less explicit.Callback Flush Timing ​When you mutate reactive state, it may trigger both Vue component updates and watcher callbacks created by you.By default, user-created watcher callbacks are called before Vue component updates. This means if you attempt to access the DOM inside a watcher callback, the DOM will be in the state before Vue has applied any updates.If you want to access the DOM in a watcher callback after Vue has updated it, you need to specify the flush: 'post' option:jsexport default {
  // ...
  watch: {
    key: {
      handler() {},
      flush: 'post'
    }
  }
}
jswatch(source, callback, {
  flush: 'post'
})

watchEffect(callback, {
  flush: 'post'
})
Post-flush watchEffect() also has a convenience alias, watchPostEffect():jsimport { watchPostEffect } from 'vue'

watchPostEffect(() =&gt; {
  /* executed after Vue updates */
})
this.$watch() ​It's also possible to imperatively create watchers using the $watch() instance method:jsexport default {
  created() {
    this.$watch('question', (newQuestion) =&gt; {
      // ...
    })
  }
}
This is useful when you need to conditionally set up a watcher, or only watch something in response to user interaction. It also allows you to stop the watcher early.Stopping a Watcher ​Watchers declared using the watch option or the $watch() instance method are automatically stopped when the owner component is unmounted, so in most cases you don't need to worry about stopping the watcher yourself.In the rare case where you need to stop a watcher before the owner component unmounts, the $watch() API returns a function for that:jsconst unwatch = this.$watch('foo', callback)

// ...when the watcher is no longer needed:
unwatch()
Watchers declared synchronously inside setup() or &lt;script setup&gt; are bound to the owner component instance, and will be automatically stopped when the owner component is unmounted. In most cases, you don't need to worry about stopping the watcher yourself.The key here is that the watcher must be created synchronously: if the watcher is created in an async callback, it won't be bound to the owner component and must be stopped manually to avoid memory leaks. Here's an example:vue&lt;script setup&gt;
import { watchEffect } from 'vue'

// this one will be automatically stopped
watchEffect(() =&gt; {})

// ...this one will not!
setTimeout(() =&gt; {
  watchEffect(() =&gt; {})
}, 100)
&lt;/script&gt;
To manually stop a watcher, use the returned handle function. This works for both watch and watchEffect:jsconst unwatch = watchEffect(() =&gt; {})

// ...later, when no longer needed
unwatch()
Note that there should be very few cases where you need to create watchers asynchronously, and synchronous creation should be preferred whenever possible. If you need to wait for some async data, you can make your watch logic conditional instead:js// data to be loaded asynchronously
const data = ref(null)

watchEffect(() =&gt; {
  if (data.value) {
    // do something when data is loaded
  }
})
Edit this page on GitHub