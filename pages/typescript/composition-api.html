TypeScript with Composition API ​This page assumes you've already read the overview on Using Vue with TypeScript.Typing Component Props ​Using &lt;script setup&gt; ` {#using-script-setup}&quot;">​When using &lt;script setup&gt;, the defineProps() macro supports inferring the props types based on its argument:vue&lt;script setup lang="ts"&gt;
const props = defineProps({
  foo: { type: String, required: true },
  bar: Number
})

props.foo // string
props.bar // number | undefined
&lt;/script&gt;
This is called "runtime declaration", because the argument passed to defineProps() will be used as the runtime props option.However, it is usually more straightforward to define props with pure types via a generic type argument:vue&lt;script setup lang="ts"&gt;
const props = defineProps&lt;{
  foo: string
  bar?: number
}&gt;()
&lt;/script&gt;
This is called "type-based declaration". The compiler will try to do its best to infer the equivalent runtime options based on the type argument. In this case, our second example compiles into the exact same runtime options as the first example.You can use either type-based declaration OR runtime declaration, but you cannot use both at the same time.We can also move the props types into a separate interface:vue&lt;script setup lang="ts"&gt;
interface Props {
  foo: string
  bar?: number
}

const props = defineProps&lt;Props&gt;()
&lt;/script&gt;
Syntax Limitations ​In order to generate the correct runtime code, the generic argument for defineProps() must be one of the following:An object literal type:tsdefineProps&lt;{ /*... */ }&gt;()
A reference to an interface or object literal type in the same file:tsinterface Props {/* ... */}

defineProps&lt;Props&gt;()
The interface or object literal type can contain references to types imported from other files, however, the generic argument itself passed to defineProps cannot be an imported type:tsimport { Props } from './other-file'

// NOT supported
defineProps&lt;Props&gt;()
This is because Vue components are compiled in isolation and the compiler currently does not crawl imported files in order to analyze the source type. This limitation could be removed in a future release.Props Default Values ​When using type-based declaration, we lose the ability to declare default values for the props. This can be resolved by the withDefaults compiler macro:tsexport interface Props {
  msg?: string
  labels?: string[]
}

const props = withDefaults(defineProps&lt;Props&gt;(), {
  msg: 'hello',
  labels: () =&gt; ['one', 'two']
})
This will be compiled to equivalent runtime props default options. In addition, the withDefaults helper provides type checks for the default values, and ensures the returned props type has the optional flags removed for properties that do have default values declared.Without &lt;script setup&gt; ` {#without-script-setup}&quot;">​If not using &lt;script setup&gt;, it is necessary to use defineComponent() to enable props type inference. The type of the props object passed to setup() is inferred from the props option.tsimport { defineComponent } from 'vue'

export default defineComponent({
  props: {
    message: String
  },
  setup(props) {
    props.message // &lt;-- type: string
  }
})
Complex prop types ​With type-based declaration, a prop can use a complex type much like any other type:vue&lt;script setup lang="ts"&gt;
interface Book {
  title: string
  author: string
  year: number
}

const props = defineProps&lt;{
  book: Book
}&gt;()
&lt;/script&gt;
For runtime declaration, we can use the PropType utility type:tsimport type { PropType } from 'vue'

const props = defineProps({
  book: Object as PropType&lt;Book&gt;
})
This works in much the same way if we're specifying the props option directly:tsimport { defineComponent } from 'vue'
import type { PropType } from 'vue'

export default defineComponent({
  props: {
    book: Object as PropType&lt;Book&gt;
  }
})
The props option is more commonly used with the Options API, so you'll find more detailed examples in the guide to TypeScript with Options API. The techniques shown in those examples also apply to runtime declarations using defineProps().Typing Component Emits ​In &lt;script setup&gt;, the emit function can also be typed using either runtime declaration OR type declaration:vue&lt;script setup lang="ts"&gt;
// runtime
const emit = defineEmits(['change', 'update'])

// type-based
const emit = defineEmits&lt;{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}&gt;()
&lt;/script&gt;
The type argument should be a type literal with Call Signatures. The type literal will be used as the type of the returned emit function. As we can see, the type declaration gives us much finer-grained control over the type constraints of emitted events.When not using &lt;script setup&gt;, defineComponent() is able to infer the allowed events for the emit function exposed on the setup context:tsimport { defineComponent } from 'vue'

export default defineComponent({
  emits: ['change'],
  setup(props, { emit }) {
    emit('change') // &lt;-- type check / auto-completion
  }
})
Typing ref() ​Refs infer the type from the initial value:tsimport { ref } from 'vue'

// inferred type: Ref&lt;number&gt;
const year = ref(2020)

// =&gt; TS Error: Type 'string' is not assignable to type 'number'.
year.value = '2020'
Sometimes we may need to specify complex types for a ref's inner value. We can do that by using the Ref type:tsimport { ref } from 'vue'
import type { Ref } from 'vue'

const year: Ref&lt;string | number&gt; = ref('2020')

year.value = 2020 // ok!
Or, by passing a generic argument when calling ref() to override the default inference:ts// resulting type: Ref&lt;string | number&gt;
const year = ref&lt;string | number&gt;('2020')

year.value = 2020 // ok!
If you specify a generic type argument but omit the initial value, the resulting type will be a union type that includes undefined:ts// inferred type: Ref&lt;number | undefined&gt;
const n = ref&lt;number&gt;()
Typing reactive() ​reactive() also implicitly infers the type from its argument:tsimport { reactive } from 'vue'

// inferred type: { title: string }
const book = reactive({ title: 'Vue 3 Guide' })
To explicitly type a reactive property, we can use interfaces:tsimport { reactive } from 'vue'

interface Book {
  title: string
  year?: number
}

const book: Book = reactive({ title: 'Vue 3 Guide' })
TIPIt's not recommended to use the generic argument of reactive() because the returned type, which handles nested ref unwrapping, is different from the generic argument type.Typing computed() ​computed() infers its type based on the getter's return value:tsimport { ref, computed } from 'vue'

const count = ref(0)

// inferred type: ComputedRef&lt;number&gt;
const double = computed(() =&gt; count.value * 2)

// =&gt; TS Error: Property 'split' does not exist on type 'number'
const result = double.value.split('')
You can also specify an explicit type via a generic argument:tsconst double = computed&lt;number&gt;(() =&gt; {
  // type error if this doesn't return a number
})
Typing Event Handlers ​When dealing with native DOM events, it might be useful to type the argument we pass to the handler correctly. Let's take a look at this example:vue&lt;script setup lang="ts"&gt;
function handleChange(event) {
  // `event` implicitly has `any` type
  console.log(event.target.value)
}
&lt;/script&gt;

&lt;template&gt;
  &lt;input type="text" @change="handleChange" /&gt;
&lt;/template&gt;
Without type annotation, the event argument will implicitly have a type of any. This will also result in a TS error if "strict": true or "noImplicitAny": true are used in tsconfig.json. It is therefore recommended to explicitly annotate the argument of event handlers. In addition, you may need to explicitly cast properties on event:tsfunction handleChange(event: Event) {
  console.log((event.target as HTMLInputElement).value)
}
Typing Provide / Inject ​Provide and inject are usually performed in separate components. To properly type injected values, Vue provides an InjectionKey interface, which is a generic type that extends Symbol. It can be used to sync the type of the injected value between the provider and the consumer:tsimport { provide, inject } from 'vue'
import type { InjectionKey } from 'vue'

const key = Symbol() as InjectionKey&lt;string&gt;

provide(key, 'foo') // providing non-string value will result in error

const foo = inject(key) // type of foo: string | undefined
It's recommended to place the injection key in a separate file so that it can be imported in multiple components.When using string injection keys, the type of the injected value will be unknown, and needs to be explicitly declared via a generic type argument:tsconst foo = inject&lt;string&gt;('foo') // type: string | undefined
Notice the injected value can still be undefined, because there is no guarantee that a provider will provide this value at runtime.The undefined type can be removed by providing a default value:tsconst foo = inject&lt;string&gt;('foo', 'bar') // type: string
If you are sure that the value is always provided, you can also force cast the value:tsconst foo = inject('foo') as string
Typing Template Refs ​Template refs should be created with an explicit generic type argument and an initial value of null:vue&lt;script setup lang="ts"&gt;
import { ref, onMounted } from 'vue'

const el = ref&lt;HTMLInputElement | null&gt;(null)

onMounted(() =&gt; {
  el.value?.focus()
})
&lt;/script&gt;

&lt;template&gt;
  &lt;input ref="el" /&gt;
&lt;/template&gt;
Note that for strict type safety, it is necessary to use optional chaining or type guards when accessing el.value. This is because the initial ref value is null until the component is mounted, and it can also be set to null if the referenced element is unmounted by v-if.Typing Component Template Refs ​Sometimes you might need to annotate a template ref for a child component in order to call its public method. For example, we have a MyModal child component with a method that opens the modal:vue&lt;!-- MyModal.vue --&gt;
&lt;script setup lang="ts"&gt;
import { ref } from 'vue'

const isContentShown = ref(false)
const open = () =&gt; (isContentShown.value = true)

defineExpose({
  open
})
&lt;/script&gt;
In order to get the instance type of MyModal, we need to first get its type via typeof, then use TypeScript's built-in InstanceType utility to extract its instance type:vue&lt;!-- App.vue --&gt;
&lt;script setup lang="ts"&gt;
import MyModal from './MyModal.vue'

const modal = ref&lt;InstanceType&lt;typeof MyModal&gt; | null&gt;(null)

const openModal = () =&gt; {
  modal.value?.open()
}
&lt;/script&gt;
Note if you want to use this technique in TypeScript files instead of Vue SFCs, you need to enable Volar's Takeover Mode.In cases where the exact type of the component isn't available or isn't important, ComponentPublicInstance can be used instead. This will only include properties that are shared by all components, such as $el:tsimport { ref } from 'vue'
import type { ComponentPublicInstance } from 'vue'

const child = ref&lt;ComponentPublicInstance | null&gt;(null)
Edit this page on GitHub